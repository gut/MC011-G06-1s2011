Package Minijava;

Helpers
	upper_case = ['A'..'Z'];
	lower_case = ['a'..'z'];
	letter = upper_case | lower_case;
	digit = ['0'..'9'];

	cr = 13;
	lf = 10;
	eol = cr | lf | cr lf;

	unicode_input_character = [0..0xffff];
	input_character = [unicode_input_character - [cr + lf]];
	not_star =    [input_character - '*'] | eol;
	not_star_not_slash = [input_character - ['*' + '/']] | eol;

Tokens
    /* definitions */
    tok_class = 'class';
    tok_public = 'public';  /* also used for method definition */
    tok_static = 'static';
    tok_main = 'main';
    tok_extends = 'extends';

    /* operators */
    amp_amp = '&&';
    bar_bar = '||';
    minus = '-';
    plus = '+';
    star = '*';  /* also used as a pointer */

    /* types */
    boolean = 'boolean';
    int = 'int';
	string = 'String';
    void = 'void';

    /* flow control */
	if = 'if';
	else = 'else';
	while = 'while';
    return = 'return';

    /* other tokens */
	id = letter (letter | digit | '_')*;
	integer_literal = digit+;
    println = 'System.out.println';
    length = 'length';
    true = 'true';
    false = 'false';
    this = 'this';
    new = 'new';
    l_bkt = '[';
    l_brc = '{';
    l_par = '(';
    r_bkt = ']';
    r_brc = '}';
    r_par = ')';
    semi  = ';';
    comma = ',';
    dot   = '.';
    assign = '=';
    emark = '!';

	eol = eol;
	space = ' ';
	tab = 9;

	c_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';
	c_line_comment = '//' input_character* eol?;

Ignored Tokens
	c_comment, c_line_comment, space, tab, eol;

Productions
	prog = main_class class_decl;

	main_class = 
		tok_class [name]:id [main_l_brc]:l_brc 
			tok_public tok_static void tok_main l_par
				string [main]:l_bkt r_bkt [args]:id
			r_par [statement_l_brc]:l_brc
				statement
			[statement_r_brc]:r_brc 
		[main_r_brc]:r_brc;

	class_decl =
		{simple_class} tok_class [name]:id l_brc 
			var_decl*
			method_decl*
		r_brc | 

		{ext_class} tok_class [name]:id tok_extends [super]:id l_brc 
			var_decl*
			method_decl*
		r_brc;

	var_decl = type id semi;

	method_decl = 
		tok_public type [name]:id l_par
			arg_list
		r_par l_brc
			var_decl*
			statement 
			return exp semi
		r_brc;

	arg_list = 
		{void} |
		{one_more} type id arg_rest*;

	arg_rest = comma type id;

	type = 
		{int_vector} int l_bkt r_bkt |
		{int} int |
		{boolean} boolean |
		{string} string |
		{void} void |
		{id} id;

	statement = 
		/* can not be void */
		{brc} l_brc statement r_brc |
		{if} if l_par exp r_par [true]:statement else [false]:statement | 
		{while} while l_par exp r_par statement |
		{print} println l_par exp r_par semi |
		{assign} id assign exp semi |
		{assign_vector} id l_bkt [index]:exp r_bkt assign [value]:exp semi;

	exp = 
		{plus} [left]:exp plus [right]:star_term |
		{minus} [left]:exp minus [right]:star_term |
		{star_term} star_term |
		{value_vector} [id]:exp l_bkt [index]:exp r_bkt |
		{length} exp dot length |
		{call} exp dot id l_par exp_list r_par |
		{new_vector} new int l_bkt exp r_bkt |
		{new_instance} new id l_par r_par;

	star_term = 
		{times} [left]:star_term star [right]:log_term |
		{log_term} log_term;

	log_term =
		{and} [left]:log_term amp_amp [right]:not_term|
		{or} [left]:log_term bar_bar [right]:not_term |
		{not_term} not_term;

	not_term = 
		{not} emark not_term |
		{factor} factor;

	factor = 
		{id} id |
		{this} this |
		{true} true |
		{false} false |
		{integer} integer_literal |
		{exp_par} l_par exp r_par;

	exp_list = exp exp_rest*;

	exp_rest = comma exp;
	
/*vim:sw=2:ts=2:et*/
