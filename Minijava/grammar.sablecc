Package minijava;

Helpers
	upper_case = ['A'..'Z'];
	lower_case = ['a'..'z'];
	letter = upper_case | lower_case;
	digit = ['0'..'9'];

	cr = 13;
	lf = 10;
	eol = cr | lf | cr lf;

	unicode_input_character = [0..0xffff];
	input_character = [unicode_input_character - [cr + lf]];
	not_star =    [input_character - '*'] | eol;
	not_star_not_slash = [input_character - ['*' + '/']] | eol;

Tokens
    /* definitions */
    tok_class = 'class';
    tok_public = 'public';  /* also used for method definition */
    tok_static = 'static';
    tok_main = 'main';
    tok_extends = 'extends';

    /* operators */
    and = '&&';
    eq = '==';
    lt = '<';
    minus = '-';
    plus = '+';
    times = '*';  /* also used as a pointer */

    /* types */
    tok_boolean = 'boolean';
    tok_int = 'int';
	tok_string = 'String';
    tok_void = 'void';

    /* flow control */
	tok_if = 'if';
	tok_else = 'else';
	tok_while = 'while';
    tok_return = 'return';

    /* other tokens */
    tok_print = 'System.out.println';
    tok_length = 'length';
    tok_true = 'true';
    tok_false = 'false';
    tok_this = 'this';
    tok_new = 'new';
    tok_null = 'null';

    id = letter (letter | digit | '_')*;
    integer_literal = digit+;
    l_brack = '[';
    l_brace = '{';
    l_paren = '(';
    r_brack = ']';
    r_brace = '}';
    r_paren = ')';
    semi  = ';';
    comma = ',';
    period = '.';
    assign = '=';
    not = '!';

	eol = eol;
	white_space = ' ';
	tab = 9;

	block_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';
	line_comment = '//' input_character* eol?;

Ignored Tokens
	block_comment, line_comment, white_space, tab, eol;

Productions
	prog {-> prog} = main_class class_decl*
		{-> New prog(main_class.main_class, [class_decl.class_decl])};

	main_class {-> main_class} = 
		tok_class [name]:id 
		[class_l_brace]:l_brace 
			tok_public tok_static tok_void tok_main 
					l_paren tok_string l_brack r_brack [args]:id r_paren
			[function_l_brace]:l_brace
				statement*
			[function_r_brace]:r_brace 
		[class_r_brace]:r_brace 
			{-> New main_class(name, args, [statement.statement])} ;

	class_decl {-> class_decl} =
		{simple_class} tok_class [name]:id
		l_brace 
			var_decl*
			method_decl*
		r_brace 
			{-> New class_decl.simple_class(
				name, [var_decl.var_decl], [method_decl.method_decl]
			)} | 

		{ext_class} tok_class [name]:id tok_extends [super]:id
		l_brace 
			var_decl*
			method_decl*
		r_brace
			{-> New class_decl.ext_class(
				name, super, [var_decl.var_decl], [method_decl.method_decl]
			)};

	var_decl {-> var_decl} = type id semi
		{-> New var_decl(type.type, id)};

	method_decl {-> method_decl} = 
		tok_public type [name]:id l_paren arg_list? r_paren
		l_brace
			var_decl*
			statement*
			tok_return exp semi
		r_brace
			{-> New method_decl(
				type, name, arg_list.arg_list, [var_decl.var_decl],
				[statement.statement], exp.exp
			)};

	arg_list {-> arg_list} = {one_more} type id arg_rest*
			{-> New arg_list.one_more(type.type, id, [arg_rest.arg_list])};

	arg_rest {-> arg_list} = comma type id
		{-> New arg_list.arg_rest(type.type, id)};

	type {-> type} = 
		{int_vector} tok_int l_brack r_brack 
			{-> New type.int_vector(tok_int)} |
		{int} tok_int
			{-> New type.int(tok_int)} |
		{boolean} tok_boolean
			{-> New type.boolean(tok_boolean)} |
		{string} tok_string
			{-> New type.string(tok_string)} |
		{void} tok_void
			{-> New type.void(tok_void)} |
		{id} id
			{-> New type.id(id)};

	/* treating ifs */
	/*
	 *always bind the ELSE to the last IF defined, so
	 *    if (X)  if (Y) S1  else S2
	 * is the same as:
	 *    if (X) {if (Y) S1  else S2}
	 * and NOT the same as:
	 *    if (X) {if (Y) S1} else S2
	 */
	statement {-> statement} = 
		{brc} l_brace statement+ r_brace
			{-> New statement.brc([statement.statement])} | 
		{while} tok_while l_paren exp r_paren statement
			{-> New statement.while(exp.exp, statement.statement)} | 
		{print} tok_print l_paren exp? r_paren semi
			{-> New statement.print(exp.exp)} | 
		{assign} id assign exp semi
			{-> New statement.assign(id, exp.exp)} | 
		{assign_vector} id l_brack [index]:exp r_brack assign [value]:exp semi
			{-> New statement.assign_vector(id, index.exp, value.exp)} |
		{if_only} tok_if l_paren exp r_paren statement
			{-> New statement.if_only(exp.exp, statement.statement)} |
		{if_else} tok_if l_paren exp r_paren [true]:statement_no_short_if tok_else [false]:statement
			{-> New statement.if_else(exp.exp, true.statement, false.statement)};

	statement_no_short_if {-> statement} =
		{brc} l_brace statement+ r_brace
			{-> New statement.brc([statement.statement])} | 
		{while} tok_while l_paren exp r_paren statement_no_short_if
			{-> New statement.while(exp.exp, statement_no_short_if.statement)} | 
		{print} tok_print l_paren exp? r_paren semi
			{-> New statement.print(exp.exp)} | 
		{assign} id assign exp semi
			{-> New statement.assign(id, exp.exp)} | 
		{assign_vector} id l_brack [index]:exp r_brack assign [value]:exp semi
			{-> New statement.assign_vector(id, index.exp, value.exp)} |
		{if_else} tok_if l_paren exp r_paren [true]:statement_no_short_if tok_else [false]:statement_no_short_if
			{-> New statement.if_else(exp.exp, true.statement, false.statement)};

	exp {-> exp} =
		{void} exp_void
			{-> exp_void.exp} |
		{new} exp_new
			{-> exp_new.exp} |
		{cmp} exp_cmp
			{-> exp_cmp.exp};

	exp_void {-> exp} =
		{new_vector} tok_new tok_int matrix+
			{-> New exp.new_vector([matrix.exp])};

	exp_new {-> exp} =
		{new_instance} tok_new id l_paren r_paren
			{-> New exp.new_instance(id)};

	exp_cmp {-> exp} = 
		{and} [left]:exp_cmp and [right]:inequation_term
			{-> New exp.and(left.exp, right.exp)} |
		{inequation_term} inequation_term
			{-> inequation_term.exp};

	inequation_term {-> exp} =
		{eq} [left]:inequation_term eq [right]:plus_term
			{-> New exp.eq(left.exp, right.exp)} |
		{less} [left]:inequation_term lt [right]:plus_term
			{-> New exp.less(left.exp, right.exp)} |
		{plus_term} plus_term
			{-> plus_term.exp};

	plus_term {-> exp} =
		{plus} [left]:plus_term plus [right]:times_term 
			{-> New exp.plus(left.exp, right.exp)} |
		{minus} [left]:plus_term minus [right]:times_term
			{-> New exp.minus(left.exp, right.exp)} |
		{times_term} times_term 
			{-> times_term.exp};

	times_term {-> exp} = 
		{times} [left]:times_term times [right]:not_term
			{-> New exp.times(left.exp, right.exp)} |
		{not_term} not_term
			{-> not_term.exp};

	not_term {-> exp} = 
		{not} not not_term
			{-> New exp.not(not_term.exp)} |
		{exp_value} exp_value
			{-> exp_value.exp};

	exp_value {-> exp} = 
		{value_vector} [id]:exp_value [index]:matrix
			{-> New exp.value_vector(id.exp, index.exp)} |
		{exp_method} exp_method
			{-> exp_method.exp};

	exp_method {-> exp} =
		/* Exp Method */
		{length} exp_method period tok_length
			{-> New exp.length(exp_method.exp)} |
		{call}	[obj]:exp_method period id l_paren [args]:exp_list? r_paren
			{-> New exp.call(obj.exp, id, args.exp_list)} |
		/* Exp New */
		{length_void} exp_void period tok_length
			{-> New exp.length(exp_void.exp)} |
		{call_new}	[obj]:exp_new period id l_paren [args]:exp_list? r_paren
			{-> New exp.call(obj.exp, id, args.exp_list)} |
		{factor} factor
			{-> factor.exp};

	factor {-> exp} = 
		{id} id
			{-> New exp.id(id)} |
		{this} tok_this
			{-> New exp.this(tok_this)} |
		{null} tok_null
			{-> New exp.null(tok_null)} |
		{true} tok_true
			{-> New exp.true(tok_true)} |
		{false} tok_false
			{-> New exp.false(tok_false)} |
		{integer} integer_literal
			{-> New exp.integer(integer_literal)} |
		{exp_par} l_paren exp r_paren
			{-> exp.exp};

	matrix {-> exp} = 
		l_brack exp_method r_brack
			{-> exp_method.exp};

	exp_list {-> exp_list} = exp exp_rest*
		{-> New exp_list.exp_list(exp.exp, [exp_rest.exp_list])};

	exp_rest {-> exp_list} = comma exp
		{-> New exp_list.exp_rest(exp.exp)};
	
Abstract Syntax Tree
	prog = main_class class_decl*;
	main_class = [name]:id [args]:id statement*;
	class_decl = {simple_class} [name]:id var_decl* method_decl* |
		{ext_class} [name]:id [super]:id var_decl* method_decl*;
	var_decl = type id;
	method_decl = type [name]:id arg_list? var_decl* statement* exp;
	arg_list = {one_more} type id arg_list* |
		{arg_rest} type id;
	type = {int_vector} tok_int |
		{int} tok_int |
		{boolean} tok_boolean |
		{string} tok_string |
		{void} tok_void |
		{id} id;
	statement = {brc} statement+ |
		{if_only} exp statement |
		{if_else} exp [true]:statement [false]:statement |
		{while} exp statement |
		{print} exp? |
		{assign} id exp |
		{assign_vector} id [index]:exp [value]:exp;
	exp = {plus} [left]:exp [right]:exp |
		{minus} [left]:exp [right]:exp |
		{value_vector} [id]:exp [index]:exp |
		{length} exp |
		{call} exp id exp_list? |
		{new_vector} exp+ |
		{new_instance} id |
		{times} [left]:exp [right]:exp |
		{and} [left]:exp [right]:exp |
		{less} [left]:exp [right]:exp |
		{eq} [left]:exp [right]:exp |
		{not} exp |
		{id} id |
		{this} tok_this |
		{null} tok_null |
		{true} tok_true |
		{false} tok_false |
		{integer} integer_literal;
	exp_list = {exp_list} exp exp_list* |
		{exp_rest} exp;

/*vim:sw=2:ts=2:et*/
